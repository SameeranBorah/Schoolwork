\documentstyle{article}

\begin{document}
John F. Lake, Jr. 
CSE 20189 HW $#$3
\setlength{\parindent}{0in}
\section{All Utilities} 
\begin{verbatim}
1.) grep 'Nick.*"' filename
2.)  sed -n '/Nick.*"/p' filename
3.)  awk '/Nick.*"/{print $0}' filename

(".." denotes a command continuing on the next line.)

4.) grep -E  '(([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}..
		([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])' messages

5.) sed -rn  '/(([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}..
		([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])/p' messages

6.) awk '/(([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.)..
	(([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.)..
	(([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.)..	
	([01]?[0-9][0-9]?|2[0-4][0-9]|25[0-5])/' messages
\end{verbatim}
\section{sed}

\begin{verbatim}
7.) sed -e 's/\<pow\>/powVariable/g' -e 's/\<sqrt\>/sqrtVariable/g'  main.c

8.)$ sed -e 's/Object Oriented Programming/OOP/g'
	 -e '0,/OOP/s/OOP/Object Oriented Programming (&)/' TechReport.txt
\end{verbatim}

\section{grep}
\begin{verbatim}
9.) find $files/hw4 -type f -exec grep -nH 'gnarly$' {} \;

10.) grep  -cv '^\s*$' main.c
\end{verbatim}

\section{awk}
\begin{verbatim}
11.) awk -F , '{if($1>$2){print $1} else{print $2}}' numbers.txt

12.) Using the command "ps au | awk '/^root/ {x += $3}
		        END{printf("%CPU of root: %f\n",x)}'",
     I found the number to be 0.0.
\end{verbatim}
\section{My choice}
\begin{verbatim} 
13.)
grep -c 'DPT=80 ' messages
grep -c 'DPT=22 ' messages

\end{verbatim} 
\begin{tabular}{ | c | c | } 
\hline 
Port #: & Connection Attempts: \\ \hline 
Port 80 & 4573 \\ \hline 
Port 22 & 3395 \\ \hline 
\end{tabular} 
\begin{verbatim}

I chose grep for #13 because it all ws me to search for the lines containing
 "DPT=80" or "DPT=22", but I was unsure of how to get both in one command.   

The commands check for lines containing DPT=80 or DPT=22, using regular expressions,
and return the number of lines found. 

14.)awk -F : '{
	det = $2*$2-4.0*$1*$3;
	if(det<0){
		printf("NaN:NaN\n");
	} else{
		printf("(x1:%.2f),(x2:%.2f)\n",(-$2 + sqrt(det))/(2*$1),(-$2 - sqrt(det))/(2*$1));
	}
}' coefs.txt

I chose awk for this because of the multiple number of things it can do at once.  
The command cycles through all lines, using : as the delimiter, and checks if the 
determinant of the a:b:c coefficient combination is positive.  If it isn't, it will 
print "NaN:NaN"; if it is, it will print the resulting roots, x1 and x2.  


\end{verbatim}
\end{document}
